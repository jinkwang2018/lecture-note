-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [SQL 1차 학습 START] 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [02.26]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [단일 table START]
CREATE TABLE EMP
(EMPNO number not null,
ENAME VARCHAR2(10),--10byte를 넣을수 있다.
JOB VARCHAR2(9),
MGR number ,
HIREDATE date,
SAL number ,
COMM number ,
DEPTNO number );
--alter session set nls_date_format='YYYY-MM-DD HH24:MI:SS';

INSERT INTO EMP VALUES --data 넣는 구문
(7369,'SMITH','CLERK',7902,'1980-12-17',800,null,20);
INSERT INTO EMP VALUES
(7499,'ALLEN','SALESMAN',7698,'1981-02-20',1600,300,30);
INSERT INTO EMP VALUES
(7521,'WARD','SALESMAN',7698,'1981-02-22',1250,200,30);
INSERT INTO EMP VALUES
(7566,'JONES','MANAGER',7839,'1981-04-02',2975,30,20);
INSERT INTO EMP VALUES
(7654,'MARTIN','SALESMAN',7698,'1981-09-28',1250,300,30);
INSERT INTO EMP VALUES
(7698,'BLAKE','MANAGER',7839,'1981-04-01',2850,null,30);
INSERT INTO EMP VALUES
(7782,'CLARK','MANAGER',7839,'1981-06-01',2450,null,10);
INSERT INTO EMP VALUES
(7788,'SCOTT','ANALYST',7566,'1982-10-09',3000,null,20);
INSERT INTO EMP VALUES
(7839,'KING','PRESIDENT',null,'1981-11-17',5000,3500,10);
INSERT INTO EMP VALUES
(7844,'TURNER','SALESMAN',7698,'1981-09-08',1500,0,30);
INSERT INTO EMP VALUES
(7876,'ADAMS','CLERK',7788,'1983-01-12',1100,null,20);
INSERT INTO EMP VALUES
(7900,'JAMES','CLERK',7698,'1981-10-03',950,null,30);
INSERT INTO EMP VALUES
(7902,'FORD','ANALYST',7566,'1981-10-3',3000,null,20);
INSERT INTO EMP VALUES
(7934,'MILLER','CLERK',7782,'1982-01-23',1300,null,10);

COMMIT; --이 구문을 넣어야 실행을 할 수 있다.

CREATE TABLE DEPT
(DEPTNO number,
DNAME VARCHAR2(14),
LOC VARCHAR2(13) );

INSERT INTO DEPT VALUES (10,'ACCOUNTING','NEW YORK');
INSERT INTO DEPT VALUES (20,'RESEARCH','DALLAS');
INSERT INTO DEPT VALUES (30,'SALES','CHICAGO');
INSERT INTO DEPT VALUES (40,'OPERATIONS','BOSTON');

COMMIT;



CREATE TABLE SALGRADE
( GRADE number,
LOSAL number,
HISAL number );

INSERT INTO SALGRADE VALUES (1,700,1200);
INSERT INTO SALGRADE VALUES (2,1201,1400);
INSERT INTO SALGRADE VALUES (3,1401,2000);
INSERT INTO SALGRADE VALUES (4,2001,3000);
INSERT INTO SALGRADE VALUES (5,3001,9999);
COMMIT;

select*from emp;
select*from dept;
select*from SALGRADE;

/*
SELECT [DISTINCT] {*, column [alias], . . .}
        FROM table_name [WHERE condition]
        [ORDER BY {column, expression} [ASC | DESC]];
*/
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------1.사원 테이블에서 (모든데이터를 출력하세요)
select*from emp;
SELECT * FROM EMP; --쿼리문은 대소문자 구분이 없다.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------2.특정 컬럼 데이터 추출하기
select empno,ename,job,sal from emp;

select empno from emp;

select hiredate,sal,comm from emp;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------3.컬럼에 가명칭(alias)부여하기
select empno 사번, ename 이름
from emp;

select empno "사    번", ename "이    름"
from emp;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------정식 표기법(ansi 문법) >>권장
select empno as "사    번", ename as "이    름"
from emp;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Oracle : 문자열을 표현할 때 문자 데이터는 엄격하게 대소문자를 구별한다.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------소문자와 대문자는 다른 문자이다.
select*from emp where ENAME = 'KING';
select*from emp where ENAME = 'king';
select*from emp where ENAME = 'King';

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Oracle : 연산자(결합 연산자) >> || >> 'hello'||'world' >> 'helloworld'
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Java : +연산자(숫자 + 숫자 연산)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Java : +연산자(문자 + 문자 결합)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ms-sql : java와 같다.

select '사원의 이름은 ' || ename || '입니다.' as "ename"
from emp;

select '사원의 이름은 ' || sal || '입니다.' as "ename"
from emp;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------****** table이 가지는 컬럼의 기본타입을 봐야 결합을 할 수 잇다**********
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------컬럼이 숫자 타입일까, 문자일까
desc emp; --가장 기본적인 타입 확인을 위해서 사용한다.

select empno || ename as "결합"
from emp; -----내부적으로 자동 형변환을 한다. (숫자 ->문자) to_char()

select empno + ename as "결합" -----실제 연산 작업은 error > invalid number.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------중복 데이터 제거 : 키워드(distinct)
select distinct job from emp;

select distinct deptno from emp; --grouping 해서 대표로 한개 씩만 뽑는다.

select distinct job , deptno from emp order by job; --job으로 묶고 deptno
select distinct deptno , job from emp order by deptno;--deptno로 묶고 job

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------오라클 언어(SQL) : structure quary language
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------java 같은 언어다(연산자)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------java 거의 동일(%나머지 연산자) >> Oracle에서는 검색 패턴이다. >>연산자로 사용 불가이다.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Oracle >> Mod()라는 함수가 있다.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------산술(+,-,*,/,....) + Mod()함수 이다.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------사원 table에서 사원의 급여를 100달러 인상한 결과를 출력하세요.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------1.컬럼의 타입(Type)>> number
desc emp;
select empno, ename,sal , sal + 100 as "인상급여" 
from emp;

select 100 + 100 from dual; -- data Test 임시 dual
select 100 || 100 from dual; -- 순자 문자로 자동 형변환(결합)
select '100' + 100 from dual; -- 문자 >> 숫자 형변환
select 'A100' + 100 from dual; -- error

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------비교 연산자
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------java 같다(==) , 할당(=)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Oracle 같다(=) , 같지 않다(!=)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------논리 연산자
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------AND,OR,NOT

/*
SELECT [DISTINCT] {*, column [alias], . . .}
        FROM table_name
        [WHERE condition]
        [ORDER BY {column, expression} [ASC | DESC]];
*/
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------조건절(원하는 row 가지고 오겠다)
select*
from emp
where sal >= 3000;

select empno , sal
from emp
where sal >= 3000;

--이상,이하 (=포함)
--초과,미만 

--사번이 7788번인 사원의 사번, 이름 직종,입사일을 출력하세요.
select empno , ename , job , hiredate
from emp
where empno = 7788;

--사원의 이름이 king인 사원의 사번, 이름 , 급여를 출력하세요.
select empno , ename , sal
from emp
where ename = 'KING'; --대소문자 엄격하게 구분한다.(variable charactor2(20)...)

--급여가 2000$이상이면서 직종이 manager인 사원의 모든 정보를 출력하세요
select*
from emp
where sal >= 2000 and job = 'MANAGER';

--튜닝의 가장 기본
--select 절
--from 절
--where 절
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------[02.27]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Oracle 날짜
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------서버의 날짜
--시스템(웹사이트) 제작 : 날짜 >> sysdate
--게시판  : insert into board(writer , title , content , regdate)
--                values('홍길동' , '방가방가' , '피곤해요', sysdate);
--TIP >> ms-sql >>select getdate()...
select sysdate from dual; -- 날짜를 가져온다.

select hiredate from emp;
desc emp;

--오라클 시스템 정보를 담고 테이블 
select*from SYS.NLS_SESSION_PARAMETERS; -- --환경설정 정보
--NLS_DATE_FORMAT >> RR/MM/DD
--NLS_DATE_LANGUAGE >> KOREAN
--NLS_TIME_FORMAT >> HH24:MI:SSXFF

select*from SYS.NLS_SESSION_PARAMETERS where parameter = 'NLS_DATE_FORMAT';
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------현재 접속한 사용자(Session)을 기준으로 적용
alter session set nls_date_format='YYYY-MM-DD HH24:MI:SS';
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------날짜 형식을 바꾼다. 우리가 원하는 형식으로 사용하는 사용자가 보는 환경에서만 변경, 시스템을 변경한 것이 아니다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------현재 접속을 해제하고 다시 접속하면 default상태로 복구가 되어있다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------다른 곳에서 bituser로 다른 사용자가 접속하면 >> 날짜 Format은 default값이다.

select sysdate from dual;
select hiredate from emp;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Oracle 날짜 표기 : '날짜'
select*from emp
where hiredate = '1980-12-17'; --날짜형식으로 인정

select*from emp
where hiredate = '1980/12/17'; --날짜형식으로 인정

select*from emp
where hiredate = '80-12-17'; --인정이 안된다. YYYY가 아니므로 무조건 형식을 맞추어야 한다.

--사원의 급여가 2000$이상이고 4000$이하인 모든 사원의 정보를 출력
select*
from emp
where sal >=2000 and sal <=4000;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------연산자 : 컬럼명 between A and B(=을 포함한다.) >>and를 연결
select*
from emp
where sal between 2000 and 4000; 
--사원의 급여가 2000$초과이고 4000$미만인 모든 사원의 정보를 출력
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------을 할 때에는 =이 포함되지 않으므로 between을 사용하면 안된다.
select*
from emp
where sal >2000 and sal <4000 ; 

--부서 번호가 10 또는 20번 또는 30번인 사원의 사번, 이름, 급여, 부서번호를 출력하세요
select empno,ename,sal,deptno
from emp
where deptno = 10 or deptno = 20 or deptno = 30;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- IN연산자 : in(조건,조건,조건)  >> 또는을 연결
select empno,ename,sal,deptno
from emp
where deptno in(10,20,30); --컬럼은 한개만 사용가능하다.

select empno,ename,sal,deptno
from emp
where deptno != 10 and  deptno !=20;

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- NOT IN 연산자 : not in(조건,조건,조건) >> and 부정값 , and 부정값 >>  in의 반대
select empno,ename,sal,deptno
from emp
where deptno not in(10,20);

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------POINT : 값이 없다(데이터 없다) >> null

create table member(
 userid varchar2(20) not null,
 name varchar2(20) not null,
 hobby varchar2(20) --생략하면 default로 null이 붙는다. null값을 허용한다. >> 필수 입력사항이 아니다.
);

select*from member;
insert into member(USERID,HOBBY) values('hong','농구');
--ORA-01400: cannot insert NULL into ("SYSTEM"."MEMBER"."NAME") >> name에 값을 안넣으면 안된다.
insert into member(USERID,name) values('hong','홍길동'); --hobby 값을 넣지 않으면 null값이다.
insert into member(USERID,name,hobby) values('hong','홍길동','야구');
commit;

--수당을 받지 않는 모든 사원의 정보를 출력하세요.
select*
from emp
where comm = null; --은 존재하지 않는다.

select*
from emp
where comm is null; -- null은 is로 받아야한다.

--수당을 받는 모든 사원의 정보를 출력하세요
select*
from emp
where comm is not null;  

--사원테이블에서 사번, 이름, 급여, 수당, 총급여를 출력하세요.
--총급여는(급여 + 수당)
select EMPNO,ENAME,SAL,COMM,sal+comm as "총급여"
from emp;

--POINT null
--null과의 모든 연산은 결과가 null이다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------위의 문제를 해결하기 위해서 null을 처리할 수 있는 함수를 만든다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------nvl() , nvl2() **********************************************************************************
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ms-sql >> convert()
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------my-sql >> IFNULL()
select EMPNO,ENAME,SAL,COMM,sal+nvl(comm,0) as "총급여"
from emp;

select 1000 + null from dual;

select 1000 + nvl(null,0) from dual;

select comm,nvl(comm,0) from emp;

--사원의 급여가 1000$이상이고 수당을 받지않는 사원의 사번, 이름, 직종, 급여, 수당을 출력하세요
select empno,ename,job,sal,comm
from emp
where sal >= 1000 and comm is null;

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------DQL(data quary language) : SELECT
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------DDL(data difinitial language) : CREATE, ALTER, DROP : 객체생성, 수정, 삭제
create table board(
 boardid number not null, --필수 입력
 title varchar2(20) not null, --영문자,특문, 공백 20자, 한글 10자
 content varchar2(2000) not null,
 hp varchar2(20)
 );
 
 desc board;
 --insert, update, delete 작업시에는 (rollback, commit)반드시 수행
 insert into board(boardid, title, content)
 values(100,'오라클','참쉽네');

select*from board;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------실반영 : commit
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------취소 : rollback
commit;

 insert into board(boardid, title, content)
 values(200,'자바','그립다');

--잘못 되었는데 
rollback;

 insert into board(boardid, title, content,hp)
 values(200,'자바','그립다','010-3211-4456');

select boardid,nvl(hp,'EMPTY') as "hp" from board;
--nvl() 함수는 숫자, 날짜, 문자 모두에 적용가능하다.

------------------------------------------------------------------------------------------------------------------
--문자열 검색
--주소검색  :  '역삼' 검색하면 역삼이라는 단어가 있는 문장이 다 나온다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------문자열 패턴 검색(like 연산자)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------like 연산자 (와일드카드 문자 (% : 모든 것 , _ : 한문자))결합...
select*
from emp
where ename like '%A%'; --A가 들어간 것 다 찾아라

select*
from emp
where ename like 'A%'; --대소문자 구별,A로 시작하는 것 다 찾기

select*
from emp
where ename like '%S'; -- S로 끝나는 것 다 찾기

select*
from emp
where ename like '%LL%';

select*
from emp
where ename like '%A%A%'; -- A가 붙어있던 떨어져 있던 다 뽑는다. A가 2개

select ename
from emp
where ename like '_A%'; -- 두번째 시작하는 알파벳이 A이고 뒤에는 상관없다.

select ename
from emp
where ename like '___A%'; -- _는 찾고자 하는 단어에서 알파벳의 순서를 찾는 데 사용된다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------오라클 과제(정규표현식 : ex) regexp_like))
select*from emp where REGEXP_LIKE(ename,'[A-C]');
-- 표준이다. (java, oracle, script 에서 사용 방법이 동일 하다.)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------데이터 정렬하기
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------order by 컬럼명 : 문자, 숫자, 날짜
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------오름차순 : asc : 낮은 순 (default값)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------내림차순 : desc : 높은 순

select*from emp order by sal; -- 급여가 낮은 순으로 asc
select*from emp order by sal asc;
select*from emp order by sal desc; -- 급여 많이 받는 사람이 1등

select ename from emp order by ename asc; --문자열도 정렬 가능

--입사일이 가장 늦은 순으로 정렬해서 사번, 이름, 급여, 입사일 출력
select EMPNO,ENAME,SAL,HIREDATE
from emp
order by hiredate desc;

/*
실행 순서
select       3
from         1
where       2
order by    4   select한 결과를 가지고 정렬
*/
--입사일이 늦은 순으로 직업이 manager인 사람의 사번,이름,급여,직종,입사일 을 출력하세요
select empno,ename,sal,job,hiredate
from emp
where job = 'MANAGER'
order by hiredate desc;

--문제
select deptno,job
from emp
order by deptno desc , job asc; ---grouping distinct와 같다.

--연산자
            -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------합집합(union) : 테이블과 테이블의 데이터를 합치는 것 (중복값은 배제)
            -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------합집합(union all) : 중복값 허용
            
            create table UTA(name varchar2(20));
            insert into uta(name) values('AAA');
            insert into uta(name) values('BBB');
            insert into uta(name) values('CCC');
            insert into uta(name) values('DDD');
            commit;
            select *from uta;
            
            create table UT(name varchar2(20));
            insert into ut(name) values('AAA');
            insert into ut(name) values('BBB');
            insert into ut(name) values('CCC');
            commit;
            select*from ut
            
            select*from ut
            union
            select*from uta; --중복 데이터 배제
            
            select*from ut
            union all
            select*from uta; --중복 데이터 허용
            
            --union 규칙
              --1. 대응되는 컬럼의 타입이 동일
              select empno, ename from emp
              union
              select dname,deptno from dept; --X
              
              select empno, ename from emp
              union
              select deptno,dname from dept; -- type을 맞추어야 합쳐진다.
              
                              --실무 > subquery 사용해서 union한 테[이블 가상 테이블 처럼 사용한다.
                              select empno , ename
                              from(
                                 select empno, ename from emp
                                 union
                                 select deptno,dname from dept 
                              ) order by empno desc;
              
              --2. 대응되는 컬럼의 개수가 맞아야 한다.(null로 방의 갯수를 맞추면 된다.)
              select empno,ename,job,sal from emp
              union
              select deptno,dname,loc from dept; --X 방의 갯수가 다르다.
            
              select empno,ename,job,sal from emp
              union
              select deptno,dname,loc,null from dept;
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 여기 까지 단일 테이블
 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Oracle 함수(Oracle.pdf >>p.49)
 /*
 1) 문자형 함수 : 문자를 입력 받고 문자와 숫자 값 모두를 RETURN 할 수 있다. 
 2) 숫자형 함수 : 숫자를 입력 받고 숫자를 RETURN 한다. 
 3) 날짜형 함수 : 날짜형에 대해 수행하고 숫자를 RETURN 하는 MONTHS_BETWEEN 함수를 제외하고 모두 날짜 데이터형의 값을 RETURN 한다. 
 4) 변환형 함수 : 어떤 데이터형의 값을 다른 데이터형으로 변환한다. 
 5) 일반적인 함수 : NVL, DECODE 
 */
 
 --문자열 함수
 select initcap('the super man')from dual; -- The Super Man
 
 select lower('AAA') , upper('aaaaa') from dual;
 
 select ename, lower(ename) as "ename" from emp;
 
 select * 
 from emp 
 where lower(ENAME) = 'king';             
              
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 문자의 개수를 구하는 것 (length)
select length('abcd') from dual;
select length('홍길동') from dual;
select length(' 홍a길 동') from dual;

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------결합 연산자 || 여러개를 합칠 수 있어서 확장성이 좋다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 결합 함수 concat()
select 'a' || 'b' from dual;

select concat('a','b') from dual;

select concat(ename,job)from emp;
관리자

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------부분 문자열 추출 java = substring
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------부분 문자열 추출 oracle = substr('추출할 문자열',시작되는 지점,끝나는 지점)
select substr('ABCDE',2,3) from dual; -- 2번째 부터 3개를 추출
select substr('ABCDE',1,1) from dual; -- 자기자신이 나온다.
select substr('ABCDE',3,1) from dual; --C

select substr('ABCDE',3) from dual; --3번째부터 뒤로 다나온다.
select substr('ABCDE',-2,1) from dual; --   -는 뒤에서 부터 자리수를 샌다.
select substr('ABCDE',-2,2) from dual; -- DE

--Quiz
/*
사원 테이블에서 ename컬럼 데이터에 대해서 첫글자는 소문자로 
나머지는 대문자로 출력하되 하나의 컬럼 데이터로 출력하세요
--컬럼의 가명칭 : fullname
--첫글자와 나머지 문자 사이에 공백하나 있어요
*/

select  lower(substr(ename,1,1)) || ' ' || upper(substr(ename,2)) as "fullname" 
from emp;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- lpad , rpad(채우기)
select lpad('ABC',10,'*') from dual; --lpad 왼쪽에 채운다.
select rpad('ABC',10,'#') from dual; --rpad 오른쪽에 채운다.

------Quiz
--사용자의 비번 : hong1006
--화면 : ho******출력하고 싶다. (만약에 1004이면 10**)


select rpad(substr('hong1006',1,2),9,'*') from dual;
select rpad(substr('hong1006',1,2),length('hong1006'),'*') as "password" from dual;

--emp 테이블에서 ename 컬럼의 데이터 출력하는데 첫글자만 출력하고 나머지는 *출력하세요

select rpad(substr(ename,1,1),length(ename),'*') as "ename" from emp;

 
create table member2(
  id number,
  jumin varchar2(14)
);

select * from member2;
insert into member2(id,jumin) values(100,'123456-1234567');
insert into member2(id,jumin) values(200,'234567-1234567');

commit;
--Quiz
--출력결과가 하나의 컬럼으로 100 : 123456-*******
--200 : 234567-*******
--가명칭 : "jumin"
select id || ' : ' || rpad(substr(JUMIN,1,7),length(jumin),'*') as "jumin"
from member2;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- rtrim 함수 [오른쪽 문자를 지워라] rtrim(정보 , 지워야 하는 것)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ltrim 함수 [왼쪽 문자를 지워라] ltrim(정보 , 지워야 하는 것)
select rtrim('MILLER' , 'ER') from dual;

select ltrim('MILLLLLLLLLLER' , 'MIL') from dual; -----주의

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 치환함수  replace(정보, 바꿀것 , 바꿔지는 것)

select replace('apple','a','h') from dual;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [문자열 함수 END]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [숫자 함수 START]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- round(반올림 함수) : round(반올림할 것, 반올림하고 남길 소수점 자리수)
select round(12.345,0) as "r" from dual; --정수부만 남겨라 , 12

select round(12.567,0) as "r" from dual; -- 13

select round(12.345,1) as "r" from dual; -- 12.3
select round(12.567,1) as "r" from dual; -- 12.6

select round(12.345,-1) as "r" from dual; -- 10
select round(15.345,-1) as "r" from dual; -- 20

select round(15.345,-2) as "r" from dual; --0
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- trunc(절삭 함수) :버림  trunc(정보,버리고 남길 자리수)
select trunc(12.345,0) as "r" from dual; -- 12
select trunc(12.567,0) as "r" from dual; -- 12

select trunc(12.345,1) as "r" from dual; -- 12.3
select trunc(12.567,1) as "r" from dual; -- 12.5

select trunc(12.345,-1) as "r" from dual; -- 10
select trunc(15.345,-1) as "r" from dual; -- 10

select trunc(15.345,-2) as "r" from dual; --0

select trunc(12.78978978978978978789,1) as "r" from dual; -- 12.7
select round(12.78978978978978978789,1) as "r" from dual; -- 12.8
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- mod(나누어지는 수, 나누는 수) 나머지 구하는 함수
select mod(12,10) from dual; --2
select mod(0,0) from dual; --0
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [숫자 함수 END]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [날짜 함수 START] : sysdate
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  날짜 연산(POINT) : Date + or - Number >> Date (number는 일로 계산된다)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  Date - Date >> Number ( 일수가 나온다.)
select*from SYS.NLS_SESSION_PARAMETERS where parameter = 'NLS_DATE_FORMAT';

select sysdate from dual;
select hiredate from emp;
select MONTHS_BETWEEN('2018-02-27','2010-02-27') from dual; --개월의 차 96개월

select round(MONTHS_BETWEEN(sysdate,'2010-01-01'),1) from dual;
select trunc(MONTHS_BETWEEN(sysdate,'2010-01-01'),1) from dual;

select to_date('2015-04-25') + 1000 from dual; ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------to_date('날짜') >> 문자를 날짜로 바꾸어준다.

--Quiz
/*
1.   사원테이블에서 사원들의 입사일에서 현재 날짜(sysdate) 까지의 근속월수를 구하세요
2.   한달이 31일 이라고 가정하고 근속월수를 구하세요.
*/
select trunc(months_between(sysdate,hiredate),0) as "근속월수"
from emp;

select trunc((sysdate - hiredate)/31,0)
from emp;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [변환함수 START] POINT 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- Oracle :문자,숫자,날짜
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- to_char() : 숫자 -> 문자(%100,000), 날짜 -> 문자(2018년 12월 12일) (형식 정의를 위해서)  60%
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- to_date() : 문자 -> 날짜 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- to_number() : 문자 -> 숫자 (자동 형변환이 있어서 잘 안사용한다.)
/*
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 오라클 기본 타입(데이터 타입)
create table 테이블명(컬럼명 타입) ;

문자 타입
--char(20) >> 20byte >> 고정길이 문자열 >> '홍길동' >> 6byte임에도 20byte를 사용한다.
--varchar2(20) >> 20byte >> 가변길이 문자열 >> '홍길동' >> 6byte만 사용한다.

고정된 데이터 : 남 , 여 >> 처리하려면 char 써라 (2byte)
성능상의 문제가 존재한다. char가 varchar2보다 검색을 우선시 한다. 

unicode (2byte) : 한글 , 영문자, 특수문자 , 공백 >> 2byte
nchar(20) >> 문자의 갯수 >> 실제 byte는 *2하면 된다. >> 40 byte
nvarchar2(20) 

*/
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1. to_number()
select 1+1 from dual;
select '1'+1 from dual;

select to_number('1') + 1 from dual;
select '1' + '1' from dual;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 2. to_char()  : 표에있는 형식화를 가지고 
/*
9 9 의 수는 출력 폭을 결정 999999 1234 
0 무효의 0 을 출력 099999 001234 
$ 달러 기호 $999999 $1234 
L 지역 화패 기호 L999999 \1234 
. 명시한 위치에 소수점 999999.99 1234.00 
, 명시한 위치에 콤마 999,999 1,234 
MI 우측에 마이너스 기호(음수 값) 999999MI 1234- PR 음수를 “()”로 묶는다 999999PR <1234> 
EEEE 과학적인 부호 표기 99.999EEEE 1.234E+03 
V 10 을 n 번 곱합니다. 9999V99 123400 
B 0 을 0 이 아닌 공백으로 출력 B9999.99 1234.00 
*/
select sysdate from dual;

select sysdate || '일' from dual; --날짜 , 문자 결합하면 >> 문자

--정식표현
select to_char(sysdate) || '일' from dual;

select sysdate , to_char(sysdate,'YYYY') || '년' as "YYYY"
,to_char(sysdate,'YEAR')
, to_char(sysdate,'YYYY') || '년' as "YYYY"
, to_char(sysdate,'MM')
, to_char(sysdate,'DD')
, to_char(sysdate,'DAY')
, to_char(sysdate,'DY')
from dual;

--Quiz
--입사일이 12월인 사원들의 사번, 이름, 입사일, 입사년도, 입사월을 출력하세요
select EMPNO,ENAME,HIREDATE,to_char(hiredate,'MM')
from emp
where  to_char(HIREDATE,'MM') = 12;

select to_char(hiredate,'YYYY MM DD') as "일자" from emp;

select to_char(hiredate,'YYYY"년"MM"월"DD"일"') from emp;

select '>' || to_char(12345,'9999999999999') || '<' from dual;
select '>' || to_char(12345,'9999999999999') || '<' from dual;
select '>' || to_char(12345,'0000000000000') || '<' from dual;

select '>' || to_char(12345,'$9,999,999,999,999') || '<' from dual; --문자가 출력되는 것이다.

select to_char(sal,'$999,999') as "sal" from emp;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- to_date() 문자를 날짜로
select to_date('2018-12-12','YYYY-MM-DD') from dual; --2018-12-12 00:00:00

select '2018-12-12' + 100 from dual;  --error
select to_date('2018-12-12') + 100 from dual;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [변환함수 END]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [일반함수 START] 프로그램적인 성향이 강하다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- nvl(),nvl2() --> null 처리 함수 , decode() 함수 --> java if.. , case() 함수 ->> java switch..
select comm, nvl(comm,0) from emp;

create table t_emp(
 id number(6),
 job varchar2(20)
);
insert into t_emp(id,job) values(100,'IT');
insert into t_emp(id,job) values(200,'SALES');
insert into t_emp(id,job) values(300,'MGR');
insert into t_emp(id) values(400);
insert into t_emp(id,job) values(500,'MGR');
commit;

select * from t_emp;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------1.nvl()
select id, job, nvl(job,'Empty...') from t_emp;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------2.nvl2() , null 처리 -> null인 경우와 null이 아닌 경우 둘다 정의 해야 나온다. nvl2(collum,null인 경우, null이 아닌 경우)
select id, job, nvl2(job,'AAA','BBB') from t_emp; 
select id, job, nvl2(job,job || '입니다','empty') from t_emp;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------3.decode POINT (일반 sql은 제어문이 없다 if, switch)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------decode(표현식,조건1,결과1,조건2,결과2,조건3,결과3...........,나머지 결과값);
--통계 데이터 추출
select id, job, decode(id , 100 , 'IT', 200 , 'SALES', 300 , 'MGR' , 'ETC') as "decodejob" from t_emp;

select job , decode(job,'IT',1) from t_emp;

--활용(통계) : count 는 null을 못 센다. 그러므로 포함된 것의 갯수를 셀 수 있다.
select count(decode(job,'IT',1)) as "IT" , count(decode(job,'SALES',1)) as "SALES" , count(decode(job,'MGR',1)) as "MGR"
from t_emp;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*
emp 테이블에서 부서번호가 10이면 '인사부' , 20이면 '관리부' , 30이면 '회계부' , 나머지는 '기타부서'
*/
select * from emp;
select ename, deptno, decode (deptno , 10 , '인사부' , 20 , '관리부', 30 , '회계부' , '기타부서')
from emp
order by deptno asc;

create table t_emp2(
id number(2),
jumin char(7)
);
insert into t_emp2(id,jumin) values(1, '1234567');
insert into t_emp2(id,jumin) values(2, '2234567');
insert into t_emp2(id,jumin) values(3, '3234567');
insert into t_emp2(id,jumin) values(4, '4234567');
insert into t_emp2(id,jumin) values(5, '9234567');
commit;
/*
t_emp2 table에서 id,jumin 데이터를 출력하되 jumin컬럼의 앞자리가 1이면 남성
2이면 여성 , 3이면 중성 그외는 기타로 출력하세요
컬럼명은 gender로 하세요
*/
select id ,decode(substr(jumin,1,1), 1 ,'남성' , 2 ,'여성', 3,'중성','기타') as "gender"
from t_emp2;

/*
부서번호가 20번이 사원중에서 SMITH라는 이름을 가진 사원이라면 HELLO문자 출력하고
부서번호가 20번인 사원중에서 SMITH라는 이름을 가진 사원이 아니라면 WORLD문자 출력하고
부서번호가 20번인 사원이 아니라면 ETC라는 문자를 출력하세요
*/
select deptno,ename, decode(deptno,20,decode(ename,'SMITH','HELLO','WORLD'),'ETC') as "decode" from emp; 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------4. CASE문
/*
CASE 조건 WHEN 결과1 THEN 출력1
                 WHEN 결과2 THEN 출력2
                 WHEN 결과3 THEN 출력3
                 WHEN 결과4 THEN 출력4
                 ELSE 출력5
END "컬럼명
*/
create table t_zip(
  zipcode number(10)
);

insert into t_zip(zipcode) values(2);
insert into t_zip(zipcode) values(31);
insert into t_zip(zipcode) values(32);
insert into t_zip(zipcode) values(33);
insert into t_zip(zipcode) values(41);
commit;

select * from t_zip;

select '0' || to_char(zipcode) ,
          case zipcode when 2 then '서울'
                              when 31 then '경기'
                              when 32 then '강원'
                              when 41 then '제주'
                              else '기타지역'
          end "regionname"
from t_zip; --자동 형변환되므로 문제 없다.

/*
사원테이블에서 사원급여가 1000달러 이하면 4급
1001 달러 2000달러 이하면 3급
2001 달러 3000달러 이하면 2급
3001 달러 4000달러 이하면 1급
4001 달러 이상이면 특급을 부여하는 데이터를 출력하세요

1. case 컬럼명 when 결과 then 출력 ( = )
2. case when 컬럼명 조건비교구문 then    (ex: sal < 2000 )**************************

*/
select case when sal <= 1000 then '4급'
                   when sal between 1001 and 2000 then '3급'
                   when sal between 2001 and 3000 then '2급'
                   when sal between 3001 and 4000 then '1급'
                   else '특급'
          end "급여 등급" , empno , ename , sal
from emp
order by "급여 등급" asc;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [02.28]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [일반함수 END]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [집계함수 START] 오라클 .pdf (75.page) >> group by 절과 같이 사용해야 한다. 무조건 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 모든 집계함수는 null값을 무시한다. select절에 집계함수 외에 다른 컬럼이 오면 반드시 group by절에 명시되어야 한다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 무조건 컬럼1개로 결과 값 나온다. 여러개를 한 select로 사용가능 하다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1. count(*) , count(컬럼명) >> 데이터 건수를 센다.
select count(*) from emp; --줄 수를 세는 것이다.

select count(empno) from emp; --데이터의 건수를 세는 것이다. (단 null을 무시한다.)

select count(comm) from emp; --null을 무시하니까 6건만 나온다.
select comm from emp;

select count(nvl(comm,0)) from emp; -- null을 0으로 바꾸어서 센다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 2. sum() >> 합계
--급여의 합을 구해라
select sum(sal) from emp;
--회사 수당이 총 얼마 지급되지?(평균)
select sum(comm) as "sum" from emp; --4330
--회사 규정에 따라 나뉜다.
select trunc(avg(comm)) as "avg" from emp; --721 null값을 무시해서 건수가 6이 된다.
--검증
select trunc(avg(nvl(comm,0))) from emp; --null을 0으로 바꾸어서 14명으로 바뀐다.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------null이 포함되어 있는지 확인하는 quary *********************************
select count(*) from emp where comm is null;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 3. avg()
--평균 급여를 구해라
select round(avg(sal)) from emp;
--부서별 평균 월급을 구해라
select deptno,avg(sal) from emp; -- deptno , avg의 값의 수가 달라서 error

select deptno, avg(sal) --deptno를 지우면 무슨 값의 평균인지 모른다.
from emp
group by deptno;            --값의 수가 같아서 실행 된다.
/*
grouping 원리
distinct
order by
group by
*/
--직종별 평균 급여, 급여 합, 최대 급여,건수를 출력하시오.
select job , avg(sal) as "평균급여" , sum(sal) as "급여 합", max(sal) as "최대급여", count(nvl(sal,0)) as "건수" 
from emp
group by job;

--부서별, 직종별 급여의 합을 구하세요.
select deptno , job , sum(sal) , count(sal)
from emp
group by deptno,job
order by deptno asc;
/*
select       5
from         1
where       2
group by   3
having       4
order by    6
*/


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 4. max()
select max(sal) from emp;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 5. min()
select min(sal) from emp;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 6. ETC....... >> group by having 절
/*
직종별 평균 급여가 3000$ 이상인 사원의 직종과 평균 급여를 출력하세요
--where에 평균 급여 >=3000 사용하려면 group by가 실행 되야 하는데 where에서 사용을 못한다.
--group by에 조건을 거는 것이 답이다. 
--group by 조건 거는 것은 : having 절
*/
select job,avg(sal)
from emp
group by job
having avg(sal) >= 3000;

/*
사원 테이블에서 직종별 급여의 합을 출력하되 수당은 지급받고 급여의 합이 5000$ 이상인 사원들의 목록을 출력하세요
급여의 합이 낮은 순으로 출력
*/
select * from emp;
select job , sum(sal)
from emp
where comm is not null
group by job
having sum(sal) >= 5000
order by sum(sal) asc;
/*
사원테이블에서 부서 인원이 4명 보다 많은 부서의 부서번호, 인원수, 급여의 합을 출력하세요
*/
select deptno, count(ENAME), sum(sal)
from emp
group by deptno
having count(deptno) > 4;

/*
사원테이블에서 직종별 급여의 합이 5000을 초과하는 직종과 급여의 합을 출력하세요
단 판매직종(salesman)은 제외하고 급여합으로 내림차순 정렬하세요
*/
select job, sum(sal)
from emp
where substr(job,1,1) != 'S'
group by job
having sum(sal) > 5000
order by sum(sal) desc;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [집계함수 END]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [단일 table END]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [다중 table START]
create table M (M1 char(6) , M2 char(10));
create table S (S1 char(6) , S2 char(10));
create table X (X1 char(6) , X2 char(10));

insert into M values('A','1');
insert into M values('B','1');
insert into M values('C','3');
insert into M values(null,'3');
commit;

insert into S values('A','X');
insert into S values('B','Y');
insert into S values(null,'Z');
commit;

insert into X values('A','DATA');
commit;

select * from m;
select * from s;
select * from x;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [join] ************************ null은 비교 못한다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1.등가조인(equi join) => 70% , 원테이블과 대응되는 테이블에 있는 컬럼의 데이터를 1:1 매핑
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ANSI 문법]  : 테이블 join 테이블 on ~조건절 , [inner] 테이블 join  테이블 on ~조건절
select m.m1,m.m2,s.s2 -- oracle join 문법(권장X)
from m,s
where m.M1 = s.S1;
-- 어쩐 것이 join 조건 절인지 from의 조건절인지 모호하다.
select m.m1,m.m2,s.s2 -- ANSI 문법(권장)
from m join s
on m.m1 = s.s1;

--조인 요령(select * 한 후에 필요한 컬럼만 추출하면 된다.)
select emp.EMPNO,emp.ename,emp.DEPTNO,dept.DNAME
from emp join dept
on emp.deptno = dept.deptno;

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------테이블에 가명칭 부여(테이블 이름 길이가 길때 테이블 이름 뒤에 가명칭 부여한다.
select e.EMPNO,e.ename,e.DEPTNO,d.DNAME
from emp e join dept d
on e.deptno = d.deptno;

select s.s1 , x.X2
from s join x
on s.S1 = x.X1;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------여러개의 table join
select m.m1,m.m2,s.s2,x.X2         --------oracle이다.(권장 X)
from m , s , x
where m.m1 = s.s1 and s.s1 = x.x1;

select m.m1,m.m2,s.s2,x.X2         -------- ANSI이다.(권장)
from m join s on m.m1 = s.S1
            join x on s.s1 = x.x1;
            
            
--1.HR 계정으로 이동
select * from employees;
select * from departments;
select * from locations;

--employess, departments
--1. 사번,이름(last_name),부서번호,부서이름을 출력
select e.EMPLOYEE_ID , e.LAST_NAME , e.DEPARTMENT_ID , d.department_name
from EMPLOYEES e join departments d
on e.department_id = d.department_id
order by e.EMPLOYEE_ID; --------------------------- null값이 하나 있어서 사원수 한명 줄게 나온다. 등가 조인으로는 해결이 안된다.

select * from employees where department_id is null; 

--2.사번,이름,부서번호,지역코드,도시명를 출력
select e.EMPLOYEE_ID , e.LAST_NAME , e.DEPARTMENT_ID,d.DEPARTMENT_NAME,l.LOCATION_ID,l.CITY
from EMPLOYEES e join DEPARTMENTS d on e.DEPARTMENT_ID = d.DEPARTMENT_ID 
          join LOCATIONS l on d.LOCATION_ID = l.LOCATION_ID;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 2.비등가조인(non-equi join) => 의미만 존재 => 문법 등가조인 1:1 매핑이 안될때 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------**** between을 사용한다.
--사번,이름,급여,급여등급
select e.empno , e.ename , s.grade , e.SAL
from emp e join salgrade s
on e.sal between s.losal and s.hisal;

--사번,이름,부서번호,부서명,급여,급여등급
select e.EMPNO,e.ENAME,e.DEPTNO,d.DName,e.SAL,s.GRADE
from emp e join dept d on e.deptno = d.deptno 
                  join salgrade s on e.sal between s.losal and s.hisal;
------------------join                on
------------------join                on       무제한으로 확장 가능

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 3.outer join(equi join + null) => equi join
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- outer join (두개의 테이블에서 주 , 종 관계 파악)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 문법 : left outer join  (왼쪽 주 , 오른쪽 종)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------       right outer join  (오른쪽 주 , 왼쪽 종)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------       full outer join   (left , right join > union 하면)
/*
outer join(equi join + null(남는 데이터)) =>> equi join 
outer join (두개의 테이블에서 주,종 관계 파악) >> 주인의 남는 데이터는 다 null을 쓴다. >>주인이 누구냐에 따라 다르다.

문법: 
left outer join(왼쪽이 주인)
right outer join(오른쪽이 주인)
full outer join(left,right join > union하면)

내부적으로 등가조인을 실행하고(주,종)관계를 파악해서
주인 되는 테이블에 있는 남는 데이터를 가지고 오는 것
*/
select*
from m join s
on m.M1 = s.s1;

select*
from m left outer join s
on m.m1 = s.s1;

select*
from m full outer join s
on m.m1 = s.s1;

select e.EMPLOYEE_ID , e.LAST_NAME , e.DEPARTMENT_ID , d.department_name
from EMPLOYEES e left outer join departments d
on e.department_id = d.department_id
order by e.EMPLOYEE_ID;  --사원수 107명
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 4. self join (자기참조) => 의미만 존재 => 문법 등가조인 : 테이블에 가명칭을 부여하여 사용
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ex) emp 테이블에서 smith 관리자 이름은 무었입니까
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 하나의 테이블안에서 컬럼이 다른 컬럼을 참조하는 경우
select * from emp;

select e.empno ,e.ENAME , m.EMPNO,m.ENAME
from emp e left outer join emp m ---self join 은 하나의 테이블을 두개 처럼 사용하는 것(테이블에 가명칭을 부여해서)
on e.MGR = m.EMPNO;

--사원은 14명인데 결과 13명 >> 사장님은 MGR이 null이라서

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--시험
/*
select       5
from         1
where       2
group by   3
having       4
order by    6
*/
-- 1. 사원들의 이름, 부서번호, 부서이름을 출력하라.
select e.ename , e.DEPTNO , d.dname
from emp e join DEPT d
on e.DEPTNO = d.DEPTNO;
 
-- 2. DALLAS에서 근무하는 사원의 이름, 직종, 부서번호, 부서이름을
-- 출력하라.


select e.ename , e.job , e.deptno,d.dname
from emp e join dept d 
on e.deptno = d.deptno
where d.loc = 'DALLAS';



 
-- 3. 이름에 'A'가 들어가는 사원들의 이름과 부서이름을 출력하라.
select emp.ENAME,dept.DNAME
from emp join dept on emp.DEPTNO = dept.DEPTNO
where emp.ENAME LIKE '%A%' ;



-- 4. 사원이름과 그 사원이 속한 부서의 부서명, 그리고 월급을
--출력하는데 월급이 3000이상인 사원을 출력하라.
select emp.ENAME,dept.DNAME,emp.SAL
from emp join dept on emp.DEPTNO = dept.DEPTNO
where emp.sal >=3000;
 
-- 5. 직위(직종)가 'SALESMAN'인 사원들의 직종 그 사원이름, 그리고
-- 그 사원이 속한 부서 이름을 출력하라.
select emp.job ,emp.ENAME , dept.DNAME
from emp join dept on emp.DEPTNO = dept.DEPTNO
where emp.job = 'SALESMAN';

 
-- 6. 커미션이 책정된 사원들의 사원번호, 이름, 연봉, 연봉+커미션,
-- 급여등급을 출력하되, 각각의 컬럼명을 '사원번호', '사원이름',
-- '연봉','실급여', '급여등급'으로 하여 출력하라.
--(비등가 ) 1 : 1 매핑 대는 컬럼이 없다
select e.EMPNO as "사원번호",e.ENAME as "사원이름", e.SAL as "연봉", e.sal || e.COMM as "실급여" , s.GRADE as "급여등급"
from emp e join salgrade s on e.sal between s.losal and s.hisal;

 
-- 7. 부서번호가 10번인 사원들의 부서번호, 부서이름, 사원이름,
-- 월급, 급여등급을 출력하라.
select * from salgrade;

select d.DEPTNO,d.DNAME,e.ENAME,e.sal,s.grade
from emp e join dept d on e.DEPTNO = d.DEPTNO
               join salgrade s on e.sal between s.losal and s.hisal
where e.deptno = 10;
 
 
-- 8. 부서번호가 10번, 20번인 사원들의 부서번호, 부서이름,
-- 사원이름, 월급, 급여등급을 출력하라. 그리고 그 출력된
-- 결과물을 부서번호가 낮은 순으로, 월급이 높은 순으로
-- 정렬하라.
select dept.DEPTNO,dept.DNAME,emp.ENAME,emp.SAL,salgrade.grade
from emp join dept on emp.DEPTNO = dept.DEPTNO
               join SALGRADE on emp.sal between salgrade.
group by dept.deptno , emp.sal
having dept.deptno = 10 or dept.deptno = 20
order by dept.deptno asc , emp.sal desc;
 
 
-- 9. 사원번호와 사원이름, 그리고 그 사원을 관리하는 관리자의
-- 사원번호와 사원이름을 출력하되 각각의 컬럼명을 '사원번호',
-- '사원이름', '관리자번호', '관리자이름'으로 하여 출력하라.
--SELF JOIN (자기 자신테이블의 컬럼을 참조 하는 경우)
select e.EMPNO as "사원번호",e.ENAME as "사원이름", m.EMPNO as "관리자 번호", m.ENAME as "관리자 이름"
from emp e join emp m
on e.EMPNO = m.MGR;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------[join 끝]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------[subquery START] 오라클.pdf(100.page)
사원테이블에서 사원들의 평균 월급보다 더 많은 급여를 받는 사원의 사번과 이름과 급여를 출력
select avg(sal) from emp; -- 2073 sub 
select *
from emp
where sal >2073; -- main 

select *
from emp
where sal>(select avg(sal) from emp);

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--쿼리 작성 기준
--함수를 쓰다가 해결이 안되면 join을 하고 안되면 subquery를 사용
--1.single row subquery : subquery 의 결과가 1개의 row(단일값) : 한개의 값(단일 컬럼)
--2.multi row subquery : subquery 의 결과가 1개 이상의 row : 여러개의 값(단일 컬럼) >> = ,and, or이 안먹혀서 다른 연산자를 사용해야 한다.
--구분하는 이유 ( 사용되는 연산자가 차이)
--연산자(in,not in)(any,all) >> 다중 데이터
--in : sal=1000 or sal=2000 or or...
--all : sal > 1000 and sal > 2000 and ...
--any : sal > 1000 or sal > 2000 or ...
--문법(정의)
--1.subquery는 괄호 안에 있어야 한다.
--2.subquery는 단일 컬럼으로 구성
--3.subquery는 단독으로 실행 가능 해야 한다.

--subquery를 가지고 있는 sql문장
--1. subquery먼저 실행
--2. subqurey 의 결과 값을 가지고 main을 실행한다.

--사원 테이블에서 jones의 급여보다 더 많은 급여를 받는 사원의 사번, 이릅, 급여를 출력하세요
select sal from emp where ename ='JONES';

select empno,ename,sal
from emp
where sal>(select sal from emp where ename ='JONES');

select *
from emp
where sal in (select sal from emp where sal > 2000);
--where sal =2975 or sal = 2850 or sal =2450 or sal = 3000..... 

select *
from emp
where sal not in (select sal from emp where sal > 2000);
--where sal != 2975 and sal != 2850 and sal != .....

--부하직원이 있는 사원의 사번과 이름을 출력하세요
select * from emp e join emp m on e.empno = m.mgr;

select empno,ename
from emp
where empno in(select mgr from emp);
--where empno = 7839 or empno = 7566 or empno is null or empno = 7902

--부하직원이 없는 사원의 사번과 이름을 출력하세요
select empno,ename
from emp
where empno not in(select nvl(mgr,0) from emp); 
--where empno != 7839 and empno != 7566 and empno is not null....

--직속이 king인 사원의 사번, 이름, 직종, 관리자 사번을 출력하세요
select empno from emp where ename ='KING';
select empno,ename,job,mgr
from emp
where mgr  = (select empno from emp where ename ='KING');

--20번 부서의 사원 중에서 가장 많은 급여를 받는 사원보다 더 많은 급여를 받는 사원의 
--사번,이름,급여,부서번호를 출력하세요
select max(sal) from emp where deptno = 20;

select empno , ename , sal , deptno
from emp
where sal > (select max(sal) from emp where deptno = 20);

--집계함수가 subquery활용 ....
select *
from emp
where deptno in(select deptno from emp where job = 'SALESMAN')
and sal in(select sal from emp where job = 'SALESMAN');

--QUIZ 경품
/*
자기 부서의 평균 월급보다 더 많은 월급을 받는 사원의 
사번 이름 부서번호 부서별 평균 월급을 출력하세요
*/
select avg(sal) from emp;
select avg(sal) from emp where ename;
select deptno,avg(sal) as avgsal from emp group by deptno;

select e.deptno , e.ENAME, e.DEPTNO, trunc(s.avgsal,0)
from emp e join(select deptno,avg(sal) as avgsal from emp group by deptno) s
on e.deptno = s.deptno
where e.sal > s.avgsal;

--1. 'SMITH'보다 월급을 많이 받는 사원들의 이름과 월급을 출력하라.
select sal from emp where ename ='SMITH';
 
 select EMPNO,ENAME,sal
 from emp
 where sal >(select sal from emp where ename ='SMITH');
--2. 10번 부서의 사원들과 같은 월급을 받는 사원들의 이름, 월급,
-- 부서번호를 출력하라.
select sal from emp where DEPTNO = 10;
select ename,sal,deptno
from emp
where sal in(select sal from emp where DEPTNO = 10);

 
--3. 'BLAKE'와 같은 부서에 있는 사원들의 이름과 고용일을 뽑는데
-- 'BLAKE'는 빼고 출력하라.
select deptno from emp where ename = 'BLAKE';
select ename , HIREDATE
from emp
where deptno = (select deptno from emp where ename = 'BLAKE')
and ename != 'BLAKE';


--4. 평균급여보다 많은 급여를 받는 사원들의 사원번호, 이름, 월급을
-- 출력하되, 월급이 높은 사람 순으로 출력하라.
select avg(sal) from emp;
select EMPNO,ENAME,sal
from emp
where sal > (select avg(sal) from emp)
order by sal desc;
 
--5. 이름에 'T'를 포함하고 있는 사원들과 같은 부서에서 근무하고
-- 있는 사원의 사원번호와 이름을 출력하라.
select deptno from emp where ENAME LIKE '%T%';  

select empno,ename
from emp
where deptno in(select deptno from emp where ENAME LIKE '%T%');



--6. 30번 부서에 있는 사원들 중에서 가장 많은 월급을 받는 사원보다
-- 많은 월급을 받는 사원들의 이름, 부서번호, 월급을 출력하라.
--(단, ALL(and) 또는 ANY(or) 연산자를 사용할 것)
select max(sal) from emp where deptno = 30;
 
select ename,empno,sal
from emp
where sal >(select max(sal) from emp where deptno = 30);
 
--7. 'DALLAS'에서 근무하고 있는 사원과 같은 부서에서 일하는 사원의
-- 이름, 부서번호, 직업을 출력하라.
select e.deptno
from emp e join dept d
on e.DEPTNO = d.DEPTNO
where d.loc = 'DALLAS';

select ename,deptno,job
from emp
where deptno in (select deptno
from dept
where loc = 'DALLAS');

--8. SALES 부서에서 일하는 사원들의 부서번호, 이름, 직업을 출력하라.
select deptno,ENAME,JOB
from emp
where deptno in(select deptno from dept where dname='SALES');

 
--9. 'KING'에게 보고하는 모든 사원의 이름과 급여를 출력하라
--king 이 사수인 사람 (mgr 데이터가 king 사번)
select empno from emp where ename = 'KING';
select ename,sal
from emp
where mgr = (select empno from emp where ename = 'KING');
--10. 자신의 급여가 평균 급여보다 많고, 이름에 'S'가 들어가는
-- 사원과 
--동일한 부서에서 근무하는 모든 사원의 사원번호, 이름,
-- 급여를 출력하라.
select avg(sal) from emp;
select empno,ename,sal
from emp
where sal > (select avg(sal) from emp)
and deptno in (select deptno from emp where ename like '%S%');
 
--11. 커미션을 받는 사원과 부서번호, 월급이 같은 사원의
-- 이름, 월급, 부서번호를 출력하라.
select deptno from emp where comm is not null;
select ename,sal,deptno
from emp
where deptno in(select deptno from emp where comm is not null)
and sal in(select sal from emp where comm is not null);



--12. 30번 부서 사원들과 월급과 커미션이 같지 않은
-- 사원들의 이름, 월급, 커미션을 출력하라.
select deptno from emp where deptno = 30;
select ename , sal , comm
from emp
where sal not in (select deptno from emp where deptno = 30) 
and comm not in (select deptno from emp where deptno = 30 
and comm is not null);
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [subquery END]
/*
DDL(데이터 정의어) : create , alter , drop , truncate (rename , modify)
DML(데이터 조작어) : insert, update, delete
DQL(데이터 질의어) : select
DCL(데이터 제어어) : 권한 (암호 바꾸기)(grant , revoke)
TCL(트랜잭션) : commit , rollback , savepoint(특정지점까지 돌아가는 것)
*/
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ DML START]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ INSERT START]
--DML 작업
--트랜잭션(transaction) : 하나의 논리적인 작업 단위
--은행업무의 출금업무(A라는 계좌에서 돈을 출금에서 B계좌의 이체까지) : 결과는 [성공 or 실패]
--commit[A~B 예외없이 실행되면], rollback[A~ B 예외가 생기면 처음으로 돌아간다.]
/*
 A라는 계좌에서 100만원 출금 >> update
 B라는 계좌에 100만원 입금 >> update
 두가지 update가 실행되면 commit , 하나라도 실패하면 rollback
*/
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 시스템 사전 정보 쿼리들 **************
desc emp;
--system table 통해서 다양한 정보 제공
select * from tab; -- 현재 접속한 접속계정 (각 계정이 볼수 있는 table)
select * from tab where TNAME = 'BOARD'; -- 테이블 생성 전에 그 정보를 확인
select * from col; -- 사용자가 관리하는 모든 컬럼의 정보
select * from col where tname = 'EMP'; -- 대문자로 써야한다. 특정 테이블이 가지는 컬럼 정보
select *from user_tables; -- 관리자 , 튜닝하는 사람들이 보는 것이다 아주 상세한 정보
select*from user_tables where table_name = 'DEPT'; --시스템 내부 정보를 컬럼으로 검색하는 것

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--오라클 .pdf(168.page)
/*
INSERT INTO table_name [(column1[, column2, . . . . . ])] 
VALUES  (value1[, value2, . . . . . . ]); 
*/
create table temp(
  id number primary key , --id 컬럼에 null , 중복값이 안들어간다. , 유일한 데이터 1건을 보장한다.: where id = 10이라고 입력하면 무조건 한 건만 나온다. ex)주민번호
  name varchar2(20) -- default로 null 허용한다.
  );
  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1.가장 일반적인 insert
insert into temp(id,name)
values(100,'홍길동');

select *from temp;
commit; --실 반영하고 싶을 때 백업 안해놓으면 복원 할 수 없다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 2.컬럼 리스트 생략 insert (temp(id,name) >>에서 (id,name) 생략 >>temp 모든 조건 삽입해야한다.
insert into temp --컬럼 리스트 생략 할 수 있지만 되도록이면 쓰자. 가독성을 위해서
values(200,'김유신');
commit;

insert into temp(id,name) -->>id는 기본 키로 설정 되어 있어서 중복 값은 들어갈 수 없다. unique constraint (BITUSER.SYS_C007004) violated , 무결성
values(100,'아무개');          -->> X

insert into temp(name) -->> id는 기본키로 설정 되어 있어서 null값 들어갈 수 없다. cannot insert NULL into ("BITUSER"."TEMP"."ID")
values('아무개'); --> X
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--insert 데이터 어느정도 
--일반 SQL은 제어문이 없다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- PL SQL은 제어문이 있다. ( for 문을 돌려서 정보를 넣을 수 있다.)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 무조건 블록 실행을 해야한다. 넣고 나서 주석을 만들어야 편하다. 안하면 계속 실행
/*
create table temp2(id varchar2(20));
BEGIN
  FOR i IN 1..1000 LOOP
      INSERT INTO temp2(id) VALUES ('A' || to_char(i));
    END LOOP;
  END;
  */
select * from temp2;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
create table temp3(
 memberid number(3) not null,
 name varchar2(10), --null 허용
 regdate date default sysdate -- 기본값 설정하기 (insert하지 않으면 기본값으로 서버 날짜 적용) >>ex)회원가입 할때
 );
select sysdate from dual;
insert into temp3(MEMBERID,NAME,regdate)
 values(100,'홍길동','2018-03-02');
select * from temp3;
 --특정 컬럼에 데이터 넣기
insert into temp3(memberid,name)
 values(200,'아무개'); -----default 가 동작해서 regdate컬럼에 >>sysdate값이 자동으로 들어간다.
commit;
 
insert into temp3(memberid)
 values(300);
commit;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- TIP 1)대량 데이터 insert하기 테이블이 있을때 ,  select 구문(values 구문 대신에)
create table temp4(id number);
create table temp5(num number);
insert into temp4(id) values(1);
insert into temp4(id) values(2);
insert into temp4(id) values(3);
insert into temp4(id) values(4);
insert into temp4(id) values(5);
insert into temp4(id) values(6);
insert into temp4(id) values(7);
insert into temp4(id) values(8);
insert into temp4(id) values(9);
insert into temp4(id) values(10);
commit;
select *from temp4;
--temp4테이블에 있는 모든 데이터를 temp5에 넣고 싶다.
--insert into 테이블명 (컬럼리스트) select 구문(values 구문 대신에)
--단 컬럼의 갯수와 타입이 일치하면
insert into temp5(num) 
select id from temp4;
select *from temp5;
commit;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- TIP 2)대량 데이터 insert하기 테이블 없을 때
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- as select 복사 컬럼 from 복사할 테이블 where 제약조건
--테이블을 자동으로 생성하고 대량 데이터 삽입
--단 제약 정보는 copy가 안된다.(primery key , foreign key)
--emp table과 같은 구조를 가지고 같은 데이터를 갖는 실습테이블을 만들고 싶다.
create table copyemp
as 
select*from emp;
select*from copyemp;

create table copyemp2
as
select empno, ename , job, sal from emp where deptno = 30;
select*from copyemp2;

--Quiz
--구조만 복사하고 데이터는 복사하고 싶지 않을 때? where에 무조건 거짓인 명제를 넣어준다.
create table copyemp3
as
select * from emp where 1=2;
select * from copyemp3;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  >> 주의 사항(단점) ,시스템 테이블 사용( 제약 정보 확인하기) *******************************
select*from user_constraints where table_name = 'EMP';
select*from user_constraints where table_name = 'COPYEMP';

create table pktest(id number primary key); --제약조건
insert into pktest(id) values(100);
commit;

create table pktest2
as
select*from pktest;

select*from pktest2;
select*from user_constraints where table_name = 'PKTEST';
select*from user_constraints where table_name = 'PKTEST2'; --제약 조건은 복사되지 않는다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ INSERT END]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ UPDATE START]
/*
UPDATE  table_name 
SET  column1 = value1 [,column2 = value2, . . . . . . .] 
[WHERE  condition]; 

UPDATE  table_name 
SET  (column1, column2, . . . . ) =       ( SELECT  column1,column2, . . .     FROM   table_name    WHERE  coundition)   -- subquary
[WHERE  condition]; 
*/
commit;
select* from copyemp;

update copyemp
set sal = 0;

rollback; -- 이전에 commit 한 것 전까지 rollback 된다. ( insert, update , delete에 대해서만)

update copyemp
set job = 'NOT.....'
where deptno = 20;
select * from copyemp order by deptno;
rollback;

--update (subquery와 같이 사용 많이 한다.) 
update copyemp
set sal = (select sum(sal) from copyemp);
rollback;

update copyemp
set ename = 'AAA',job = 'BBB' , hiredate = sysdate
where deptno = 10;
select * from copyemp order by deptno;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ UPDATE END]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ DELETE START]
delete from copyemp;
select * from copyemp;
rollback;

delete from copyemp where deptno = 20;
 --delete table( 기존 table의 data를 삭제한다.) >>데이터를 삭제해도 table의 공간을 줄이지 않는다.
 --truncate table( 기존 table의 data와 공간을 삭제한다.) >>데이터를 삭제하면서 공간도 줄인다 , where 조건을 사용 못한다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ DELETE END]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ DML END]
/*
app(java)  ->> jdbc ->> db(oracle)
CRUD 개발자가 하는 작업
--create : insert
--read : select (전체 조회, 조건 조회)
--update : update
--delete : delete
(create,update,delete ) transaction을 동반(commit, rollback)
--함수 최소 5개를 만드는 것 --> JDBC
--public List<Emp> getEmpList(){안에 쿼리문 select*from emp}
--public Emp getEmpListByEmpno(int empno){select... 쿼리문}
--public int insertEmp(Emp emp){insert into emo(....)}
*/
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ DDL START]
select * from user_tables where lower(table_name) = 'board';
select*from user_constraints where lower(table_name) = 'board';

create table board(
  boardid number,
  title varchar2(50),
  content varchar2(2000),
  regdate date
);
desc board;

--Oracle 11g부터 가상컬럼(조합 컬럼) 도입
-- 학생 성적 : 국어, 영어 , 수학 ,총점 컬럼이 있다.
--총점 컬럼은 설계할 때 굳이 필요가 없는데 자료조회를 빨리 하기 위해서 만들 수도 있다.
-- 국어, 영어, 수학 data가 insert되면 자동적으로 총점이 생성되게 하고 싶다. 
create table vtable(
  no1 number,
  no2 number,
  no3 number GENERATED ALWAYS as (no1 + no2) VIRTUAL
);

insert into vtable(no1,no2)
values (100,50);
insert into vtable(no1,no2)
values (80,60);
select * from vtable;
----no3 가상컬럼에 데이터를 직접 넣을 수 있나? --> INSERT operation disallowed on virtual columns ->> 안된다.
insert into vtable(no1,no2,no3)
values (100,50,200);

select COLUMN_NAME , DATA_TYPE , DATA_DEFAULT
from user_tab_columns where table_name = 'VTABLE';

--실무에 사용되는 형식의 코드
--제품정보 ( 입고일 ) 기준에 따라서 분기별로 데이터를 나누고 싶다.
--입고일 : 2018-03-02 >> 1분기 데이터
create table vtable2(
  no number,
  p_code char(4), --제품코드(A001)
  p_date char(8), --입고일(20180302)
  p_qty number, -- 수량
  p_bungi number(1) GENERATED ALWAYS as (CASE WHEN substr(p_date,5,2) IN ('01','02','03') THEN 1
                                                                                   WHEN substr(p_date,5,2) IN ('04','05','06') THEN 2
                                                                                   WHEN substr(p_date,5,2) IN ('07','08','09') THEN 3
                                                                                   ELSE 4
                                                                          END
                                ) VIRTUAL -- 가상 컬럼
);
insert into vtable2(p_date) values('20180101');
insert into vtable2(p_date) values('20180126');
insert into vtable2(p_date) values('20180401');
insert into vtable2(p_date) values('20180601');
insert into vtable2(p_date) values('20181101');
select*from vtable2;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------DDL tabla 다루기 오라클.pdf (140 page)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------1. create table
create table temp6(id number);
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------2. alter table (기존 table에 culumn 추가하기) >> add
alter table temp6 
add ename varchar2(20);

desc temp6;
select* from temp6;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------2.1. alter table (기존 table에 이름만  column 변경하기 ) >> rename
alter table temp6
rename column ename to username; 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------2.2. alter table (기존 table의 column의 type수정) >> modify
alter table temp6
modify(username varchar2(200));
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------2.3. alter table(기존 table의 column 삭제) >> drop
alter table temp6
drop column username;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 3. drop table(기존 table을 삭제한다.
drop table temp6;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ DDL END]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 테이블 제약 START],oracle.pdf(page.144) / 만드는 시점 : 테이블 만들 때(create), 테이블 생성 이후(alter) 
--데이터베이스 무결성 확보
--제약(constraint) : insert , update 주로 적용
/*
PRIMARY KEY(PK) 유일하게 테이블의 각행을 식별(NOT NULL 과 UNIQUE 조건을 만족) 
FOREIGN KEY(FK) 열과 참조된 열 사이의 외래키 관계를 적용하고 설정합니다. 
UNIQUE key(UK) 테이블의 모든 행을 유일하게 하는 값을 가진 열(NULL 을 허용) 
NOT NULL(NN) 열은 NULL 값을 포함할 수 없습니다. 
CHECK(CK) 참이어야 하는 조건을 지정함(대부분 업무 규칙을 설정) 
*/
select * from user_constraints where table_name = 'EMP'; --제약 정보 확인
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------1. NOT NULL : null 포함 안됨
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------2. UNIQUE key : 유일값 , 중복값 안됨 , null값을 가질 수 있다. >> null을 못가지게 하려면 not null을 사용
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------3. PRIMARY key : not null하고 unique한 제약 ,
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------     내부적으로 index page가 자동 설정 >> 검색을 빠르게 하기 위해서 >> 유지보수는 힘들다. 
create table temp7(
  id number constraint pk_temp7_id primary key, -->> 관용적인 표현 (제약의 축소표현_테이블명_컬럼명) 으로 이름을 붙여준다.
  --id number primary key , ->> 권장하지 않음 -- 제약의 이름이 자동으로 등록이 된다. >>제약의 이름이 sys_c006997등으로 붙여진다. >>제약이름으로 제약을 지울 때 힘들다.
  name varchar2(20) not null,
  addr varchar2(50) 
);
select * from user_constraints where table_name = 'TEMP7';

insert into temp7 (name,addr) values('홍길동','서울시 강남구'); -->>ORA-01400: cannot insert NULL into ("BITUSER"."TEMP7"."ID") : null값 error
insert into temp7 (id,name,addr) values(10,'홍길동','서울시 강남구');
insert into temp7 (id,name,addr) values(10,'김유신','서울시 강남구'); -->>unique constraint (BITUSER.PK_TEMP7_ID) violated : 중복키값 error

create table temp8(
  id number constraint pk_temp8_id primary key, --PK는 테이블 당 한개(중복 키 가능 : 묶어서 한개)
  name varchar2(20) not null,
  jumin char(6) constraint uk_temp8_jumin unique, --null을 허용한다.
  --jumin char(6) not null constraint uk_temp8_jumin unique (중복 X , null X)
  addr varchar2(20)
);
select*from user_constraints where table_name = 'TEMP8';
insert into temp8(id,name,jumin,addr) values(10,'홍길동','123456','서울시 강남구');

select * from temp8;

insert into temp8(id,name,jumin,addr) values(100,'김유신','123456','경기도 '); -->>unique constraint (BITUSER.UK_TEMP8_JUMIN) violated 중복 에러
insert into temp8(id,jumin,addr) values(200,'123456','경기도 '); -->>cannot insert NULL into ("BITUSER"."TEMP8"."NAME") 이름이 널
insert into temp8(id,name,jumin) values(20,'아무개','123456');

--테이블 생성 후에 제약 걸기
create table temp9(id number);
--기존 테이블에 제약 추가하기
--주의) 입력된 데이터가 있다면 >> 10,10 이 들어 있으면 >> pk 제약(x) >> 데이터 삭제 >>제약
alter table temp9
add constraint pk_temp9_id primary key (id);

select*from user_constraints where table_name='TEMP9';

alter table temp9 
add ename varchar2(20);

desc temp9; --테이블 기본정보
select*from user_constraints where table_name='TEMP9'; --테이블 제약 정보 

alter table temp9
modify(ename not null);

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------4. FOREIGN key  >> 테이블과 테이블 간의 관계 설정
--table과 table간의 제약 >> 관계를 확보할 수 있다.

create table c_emp
as 
  select empno,ename , deptno from emp where 1=2;

create table c_dept
as select deptno, dname from dept where 1=2;

select*from c_emp;
select * from c_dept;

--참조키(c_emp (deptno) fk -> c_dept(deptno) 컬럼을 참조하도록 ) 이 때 dept table deptno 컬럼은 기본키로 되어야 한다.
--1.
alter table c_dept
add constraint pk_dept_deptno PRIMARY key(deptno);

--2.
alter table c_emp 
add constraint fk_emp_deptno FOREIGN key(deptno) REFERENCES c_dept(deptno);

insert into c_dept(deptno,dname) values(100,'인사팀');
insert into c_dept(deptno,dname) values(200,'관리팀');
insert into c_dept(deptno,dname) values(300,'회계팀');
commit;

--사원 입사 (부서정하지 않고)
insert into c_emp(empno,ename)
values(100,'홍길동'); --fk not null을 강제하지 않는다.(null)

select * from c_emp;

insert into c_emp(empno,ename,deptno)
values(200,'김유신',500); -- 회사의 deptno는 100 200 300 밖에 없는데 500은 안들어간다.  integrity constraint (BITUSER.FK_EMP_DEPTNO) violated - parent key not found

insert into c_emp(empno,ename,deptno)
values(200,'김유신',300);
commit;

delete from c_dept where deptno = 200;--참조하고 있는 것이 없어서 지울 수 있다.
delete from c_dept where deptno = 300;--참조하고 있어서 지울 수 없으므로 참조 하고 있는 것 부터 지워야 한다.

--오라클.pdf (145.page)
/*
column datatype [CONSTRAINT constraint_name]        
REFERENCES table_ name (column1[,column2,..] [ON DELETE CASCADE]) 

column datatype, . . . . . . . ,
[CONSTRAINT constraint_name] FOREIGN KEY (column1[,column2,..])       
REFERENCES table_name  (column1[,column2,..] [ON DELETE CASCADE])

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ON DELETE CASCADE] >> 부모 테이블과 같이 사라지게 하는 것
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ms sql은 on update cascade도 있다. oracle을 delete밖에 없다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 참조하는 자식 데이터 같이 삭제
*/
alter table c_emp 
add constraint fk_emp_deptno FOREIGN key(deptno) REFERENCES c_dept(deptno) ON DELETE CASCADE; -->> 참조하는 것들을 바로 지울 수 있다.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------5. CHECK >> 설정한 범위 내의 값만 입력받겠다. ex) gender 컬럼에 '남' 또는 '여'라는 데이터만 넣고 싶다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- where gender in('남','여') 와 같다.
--where 조건과 동일한 형태 >> where gender in('남','여');
create table temp10(
id number constraint pk_temp10_id primary key,-- (묶어서 1개)
name varchar2(20) not null, --필수 입력
jumin char(6) constraint uk_temp10_jumin Unique, --필요하다면 not null을 추가하는 형태 가능하다.
addr varchar2(20), --추가 입력
age number constraint ck_temp10_age check(age >= 19)
);

desc temp10;
select*from user_constraints where table_name='TEMP10';

insert into temp10(id,name,jumin,addr,age)
values(100,'홍길동','123456','서울시 강남구',25);

select * from temp10;

insert into temp10(id,name,jumin,addr,age)
values(200,'홍길동','123457','서울시 강남구',25);

insert into temp10(id,name,jumin,addr,age)
values(300,'홍길동','123458','서울시 강남구',18); -- check constraint (BITUSER.CK_TEMP10_AGE) violated >>나이가 19가 안되므로 체크제약 위반으로 걸린다.

commit;
/*
--학생 성적 테이블
--학번의 데이터는 중복되거나 NULL 값을 허용하면 안된다
--이름 NULL 값을 허용하지 않는다
--국어
--영어
--수학 점수 컬럼은 숫자 타입이고 NULL 값을 허용
--는 값을 입력하지 않으면  default로 0값을 갖는다

--총점 ,평균 컬럼은 가상컬럼으로(조합컬럼) 생성한다
--학과코드는 학과 테이블에 학과코드를 참조한다
--학번 , 이름 , 국어 , 영어 , 수학 , 총점 , 평균 , 학과코드

--학과 테이블
--학과코드 데이터는 중복되거나 NULL 값을 허용하면 안된다,
--학과명 은 null값을 허락하지 않는다

--학과코드 , 학과명

--그리고 select 결과는
--학번 , 이름  총점, 평균 , 학과코드 , 학과명 을 출력하세요
*/
create table student(
  snumber number constraint pk_student_snumber primary key,
  sname varchar2(20) not null,
  lan number default 0,
  eng number default 0,
  math number default 0,
  total_score number GENERATED ALWAYS as (lan+eng+math) VIRTUAL,
  average_score number GENERATED ALWAYS as ((lan+eng+math)/3) VIRTUAL
  deptno number
);
create table department(
 deptno number constraint pk_student_deptno primary key,
 dname VARCHAR2(20) not null
);
alter table student 
add constraint fk_student_deptno FOREIGN key(deptno) REFERENCES department(deptno);



select * from student;
select * from department;


insert into department(deptno,dname) values (10,'화학과');
insert into department(deptno,dname) values (20,'수학과');
insert into department(deptno,dname) values (30,'컴퓨터공학과');
insert into department(deptno,dname) values (40,'철학과');

insert into student(snumber,sname,lan,eng,math,deptno)
values (1,'홍길동',45,55,90,10);
insert into student(snumber,sname,lan,eng,math,deptno)
values (2,'김유신',77,45,63,20);
insert into student(snumber,sname,lan,eng,math,deptno)
values (3,'강아지',78,12,45,30);
insert into student(snumber,sname,lan,eng,math,deptno)
values (4,'고양이',89,55,44,40);
insert into student(snumber,sname,lan,eng,math,deptno)
values (5,'김철수',11,22,53,30);
insert into student(snumber,sname,lan,eng,math,deptno)
values (6,'김영희',23,56,14,20);
insert into student(snumber,sname,lan,eng,math,deptno)
values (7,'오라클',11,78,65,10);
commit;
--학번 , 이름  총점, 평균 , 학과코드 , 학과명 을 출력하세요
select student.snumber as "학번" , student.SNAME as "이름",student.TOTAL_SCORE as "총점",round(student.AVERAGE_SCORE) as "평균",student.DEPTNO as "학과코드",department.DNAME as "학과명"
from student  join department 
on student.deptno = department.deptno;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 테이블 제약 END]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 가상테이블 VIEW START]
--오라클.pdf(192.page)
--VIEW는 가상 테이블이다, 객체이다, create를 사용하여 생성해야한다.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------create view '뷰이름' as 'view가 보는 목록'(select구문)
--view는 테이블 처럼 사용가능하다(가상 테이블이기 때문에) -> 실제하는 물리적인 table이 아니다.
--view는 메모리상에만 존재하는 가상 테이블이다. (subquery -> in line view -> from(query문))
--view는 sql문장 덩어리이다. 물리적인 테이블 처럼 사용하는 것이다.
--사용법 : 일반 테이블과 사용법이 동일하다. from , where 
--DML이 가능하다. (insert , update, delete) -> view를 통해서만 가능하다. -> 실제 view를 통해 볼 수 있는 실테이블 데이터 변경
--view 사용하는 이유 >> 개발자의 편리성 >> 복잡한 query ( join, subquery) 에 쉽게 접근 사용하기 위해서 >> 단순화할 수 있다.
--                            >>  보안적인 이유 (권한 별로 처리 ) -> 노출하고 싶은 data만 모아서 view를 만들어서 사용자에게 제공한다.

create view v_001 
as select empno,ename from emp;

select * from v_001;
select* from v_001 where empno = 7788;

create view v_002
as 
  select e.empno,e.ename,e.sal,e.deptno,d.dname 
  from emp e join dept d 
  on e.deptno = d.deptno; --복잡한 query를 단순화 한다.

select * from v_002;

create view v_003
as
  select deptno, avg(sal) as "avgsal"
  from emp
  group by deptno;

select *
from emp e join v_003 s
on e.DEPTNO = s.DEPTNO
where e.sal > s."avgsal";

--원하는 데이터가 table로 존재한다면 이라는 생각이 들면 view를 사용하자!!!!!!!!!!!!!!!!!!!
-- in line view , view 사용하면 된다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1. view 변경하기 create or replace v_007 as 구문 (수정,overwrite)
/* oracle.pdf ( 194.page)
CREATE  [OR  REPLACE]  [FORCE | NOFORCE]  VIEW view_name [(alias[,alias,...])] 
AS Subquery  
[WITH  CHECK  OPTION  [CONSTRAINT  constraint ]] 
[WITH  READ  ONLY] 

OR  REPLACE  이미 존재한다면 다시 생성한다. 
FORCE   Base Table 유무에 관계없이 VIEW 을 만든다. 
NOFORCE  기본 테이블이 존재할 경우에만 VIEW 를 생성한다. 

view_name  VIEW 의 이름 
Alias   Subquery 를 통해 선택된 값에 대한 Column 명이 된다. 
Subquery  SELECT 문장을 기술한다. 

WITH CHECK OPTION VIEW 에 의해 액세스 될 수 있는 행만이 입력,갱신될 수 있다.  
Constraint  CHECK OPTON 제약 조건에 대해 지정된 이름이다. 
WITH READ ONLY  이 VIEW 에서 DML 이 수행될 수 없게 한다. 
*/
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 2. view는 column명이 필요하다.
create or replace view v_emp
as
  select empno,ename,deptno from emp where deptno=20;

SELECT * from v_emp;
SELECT * from v_emp where deptno = 10; -- error >>v_emp는 deprno가  20번인 것만 있으므로
--view >> DML(insert, update, delete)
-- view를 통한 데이터에 대해서 DML가능하다. -->> view가 바뀌는 것이 아니라 view가 보는데이터가 바뀐다.
--단일 테이블만 >> view를 통해서
select * from v_emp;
select* from dept;

delete from v_emp; -->> deptno 20인 자료가 emp에서 삭제 된다. view가 보는 데이터만 가능하다. commit , rollback이 가능하다.
select * from emp;
--1. 30번 부서 사원들의 직위, 이름, 월급을 담는 VIEW를 만들어라.
create view view001
as
  select job,ename,sal
  from emp 
  where deptno = 30;

select * from view001;
--2. 30번 부서 사원들의  직위, 이름, 월급을 담는 VIEW를 만드는데,
-- 각각의 컬럼명을 직위, 사원이름, 월급으로 ALIAS를 주고 월급이
-- 300보다 많은 사원들만 추출하도록 하라.
-- create or replace view view001 (컬럼명, 컬럼명, .....)  
create view view002(직위,사원이름,월급)
as
  select job,ename,sal 
  from emp
  where deptno = 30 and sal>300;


select * from view002;
 
--3. 부서별 최대월급, 최소월급, 평균월급을 담는 VIEW를 만들어라.
create view view003("최대월급","최소월급","평균월급")
as
  select max(sal),min(sal),avg(sal)
  from emp
  group by deptno;
 
select * from view003;      
--4. 부서별 평균월급을 담는 VIEW를 만들되, 평균월급이 2000 이상인
-- 부서만 출력하도록 하라.
create view view004
as
  select avg(sal) as "평균월급"
  from emp
  group by DEPTNO 
  having avg(sal) >= 2000;

select * from view004;      
 

 
--5. 직위별 총월급을 담는 VIEW를 만들되, 직위가 MANAGER인
-- 사원들은 제외하고 총월급이 3000이상인 직위만 출력하도록 하라.
create or replace view view005
as
  select job,SUM(SAL) as "총월급"
  from emp
  where job != 'MANAGER'
  group by job
  having sum(sal) >=3000;
  
  select * from view005;
  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ 가상테이블 VIEW END]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ SEQUENCE START]
/*
create table board(
    boardid number primary key,
    title varchar2(50)
);
boardid >> 중복값 , null값이 없어야한다. 

게시판 글쓰기
insert into board( ) values ( )
*/
create table kboard(
num number constraint pk_kboard_num primary key,
title varchar2(50)
);
--처음 글을 쓰면 1이라는 값이 , 그 다음 부터 글을 쓰면 num에 2번 3번 으로 순차적으로 들어가기 원한다.
--JDBC : insert into kboard(title) values(?);
-->> 처음글 >> 1
-->> 다음글 >> 2,3,4
insert into kboard(num,title) 
values((select nvl(max(num),0)+1 from kboard),'4');

--delete 하고 다시 넣으려면 error
select*from kboard;
commit;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- sequence 객체 : rollback되는 자원이 아니다.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ms-sql : create table board(boardnum int identity(1,1) , title varchar(20))
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- insert into board(title) values ('제목') ; >> 숫자는 알아서
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 2012 version부터 : 오라클 처럼 sequence만들어짐

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- my-sql : create table board(boardnum int auto_increment , title varchar(20))
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- insert into board(title) values ('제목') ; >> 숫자는 알아서

/*
1.4 SEQUENCE 사용법 
테이블에 사용할 절차적인 번호를 생성하기 위해 SEQUENCE 를 사용할 수 있다. NEXTVALUE 
와 CURRVALUE 의사열을 사용하여 SEQUENCE 값을 참조한다.  
1.4.1 NEXTVAL 과 CURRVAL 의사열 
가) 특징
1) NEXTVAL 는 다음 사용 가능한 SEQUENCE 값을 반환 한다. 
2) SEQUENCE 가 참조될 때 마다, 다른 사용자에게 조차도 유일한 값을 반환한다. 
3) CURRVAL 은 현재 SEQUENCE 값을 얻는다. 
4) CURRVAL 이 참조되기 전에 NEXTVAL 이 사용되어야 한다.   
*/
create sequence board_num;

--실채번
select board_num.nextval from dual; -- 중복값이 아니고, null값이 아니라는 것을 보장 받는다.
--현재 값(채번하지 않고 정보만)
select board_num.currval from dual;


create table tboard(
  num number constraint pk_tboard_num primary key,
  title varchar2(50)
);

create sequence tboard_num;

insert into tboard(num,title)
values (tboard_num.nextval,'글쓰기');

select*from tboard;

select tboard_num.currval from dual;

delete tboard where num=5;

--게시판 10개 만든다. ex) 상품, 관리자, 회원.......... , 테이블 10개 순번은 sequence 객체 하나로 사용해도 된다.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------10에서 시작해서 2씩 증가하게 만드는 것
create sequence seq_num
start with 10
increment by 2;

select seq_num.nextval from dual;
select * from user_sequences;

--데이터 조회(게시판)
--최신글을 먼저 >> 나중에 쓴글이 먼저 나오도록
--글 번호를 순번으로 만들었으므로 
--select * from board order by boardnum desc; >> 내림차순
--개발자(sequence , rownum)
--rownum >> 의사컬럼 : 실질적으로 존재하는 것이 아니고 논리적으로 존재한다.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ROWNUM : 실제 테이블에 존재하지 않는 컬럼인데 (행에다 번호를 부여할 수 있다.)

select empno, ename from emp;

select rownum as 순번 , empno from emp;

--TOP-n 쿼리  >> table에서 조건에 맞는 상위(TOP) 레코드에서 n개 추출해라
--근거는 정렬

--ms-sql : select top 10; --> select top 10,* from emp order by sal desc;

--oracle 은 없다 , rownum을 가지고 순번을 붙여서 뽑아야한다. 반드시 기준이 필요하다.

--1.정렬 쿼리를 만든다.
select*
from emp order by sal desc;

select e.* 
from (
    select *
    from emp order by sal desc
    ) e;
--2.쿼리에 순번을 부여하고 조건절 제시
select rownum as "num", e.* 
from (
    select *
    from emp order by sal desc
    ) e
where rownum <= 10;

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  게시판 (페이징 처리 원리)
--총 100건 pagesize =10  >> 화면 한페이지에 볼 수 있는 데이터 건수 10개
--건수 / pagesize = page갯수
--pagecount = 10개
--1~100 을 10개씩 묶는다.

select * from employees;

--5번 페이지의 값을 가져온다.
select *
from(
        select rownum num ,e.*
        from(
                select * from employees order by employee_id asc
                ) e
        where rownum <= 50        
        ) s
        where num >= 40;
-- where rownum between 10 ans 20
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [ SEQUENCE END]
--QUIZ
--1> 부서테이블의 모든 데이터를 출력하라.
 select * from dept;--1> 부서테이블의 모든 데이터를 출력하라.
 
 
--2> EMP테이블에서 각 사원의 직업, 사원번호, 이름, 입사일을 출력하라.
 
--3> EMP테이블에서 직업을 출력하되, 각 항목(ROW)가 중복되지 않게
-- 출력하라.
 select distinct job
 from emp;
 
--4> 급여가 2850 이상인 사원의 이름 및 급여를 출력하라.
 
--5> 사원번호가 7566인 사원의 이름 및 부서번호를 출력하라.
select ename,deptno
from emp
where empno = 7566;
 
--6> 급여가 1500이상 ~ 2850이하의 범위에 속하지 않는 모든 사원의 이름
-- 및 급여를 출력하라.
 
 
--7> 1981년 2월 20일 ~ 1981년 5월 1일에 입사한 사원의 이름,직업 및 
--입사일을 출력하라. 입사일을 기준으로 해서 오름차순으로 정렬하라.
 select ename,job,hiredate
 from emp
 where hiredate between  and   
 order by hiredate asc;
 

 
--8> 10번 및 30번 부서에 속하는 모든 사원의 이름과 부서 번호를
-- 출력하되, 이름을 알파벳순으로 정렬하여 출력하라.
 
--9> 10번 및 30번 부서에 속하는 모든 사원 중 급여가 1500을 넘는
-- 사원의 이름 및 급여를 출력하라.
--(단 컬럼명을 각각 employee 및 Monthly Salary로 지정하시오)
 select ename as employee , sal as Monthly
 from emp
 where sal > 1500
 group by deptno
 having deptno =10 or deptno = 30;
 
--10> 관리자가 없는 모든 사원의 이름 및 직위를 출력하라.
 
 
--11> 커미션을 받는 모든 사원의 이름, 급여 및 커미션을 출력하되, 
-- 급여를 기준으로 내림차순으로 정렬하여 출력하라.
 select ename,sal,comm
 from emp
 where comm is not null and comm != 0
 order by sal desc;
 
--12> 이름의 세 번째 문자가 A인 모든 사원의 이름을 출력하라.
 
--13> 이름에 L이 두 번 들어가며 부서 30에 속해있는 사원의 이름을 
--출력하라.
 select ename
 from emp
 where ename like '%L%L%' and deptno =30;  
 
--14> 직업이 Clerk 또는 Analyst 이면서 급여가 1000,3000,5000 이 
-- 아닌 모든 사원의 이름, 직업 및 급여를 출력하라.
 
--15> 사원번호, 이름, 급여 그리고 15%인상된 급여를 정수로 표시하되 
--컬럼명을 New Salary로 지정하여 출력하라.
 select empno,ename,sal,round((sal+(sal*15/100))) as "New Salary"
 from emp;
 
 
--16> 15번 문제와 동일한 데이타에서 급여 인상분(새 급여에서 이전 
-- 급여를 뺀 값)을 추가해서 출력하라.(컬럼명은 Increase로 하라). 
 
 
 
--18> 모든 사원의 이름(첫 글자는 
-- 대문자로, 나머지 글자는 소문자로 표시) 및 이름 길이를 표시하는
-- 쿼리를 작성하고 컬럼 별칭은 적당히 넣어서 출력하라.
 
 
--19> 사원의 이름과 커미션을 출력하되, 커미션이 책정되지 않은 
-- 사원의 커미션은 'no commission'으로 출력하라.


--20> 모든 사원의 이름,부서번호,부서이름을 표시하는 질의를 작성하라.
 
 
--21> 30번 부서에 속한 사원의 이름과 부서번호 그리고 부서이름을 출력하라.
 select emp.ename , emp.deptno , dept.dname
 from emp  join dept 
 on emp.deptno = dept.deptno
 where emp.deptno = 30;
 
--22> 30번 부서에 속한 사원들의 모든 직업과 부서위치를 출력하라.
--(단, 직업 목록이 중복되지 않게 하라.)
 
 
--23> 커미션이 책정되어 있는 모든 사원의 이름, 부서이름 및 위치를 출력하라.
 select e.ename , d.deptno , d.loc
 from emp e join dept d
 on e.deptno = d.deptno
 where e.comm is not null; 
 
--24> 이름에 A가 들어가는 모든 사원의 이름과 부서 이름을 출력하라.
 
 
--25> Dallas에서 근무하는 모든 사원의 이름, 직업, 부서번호 및 부서이름을 
-- 출력하라.
 select e.ename,e.job,e.deptno,d.dname,d.loc
 from emp e join dept d
 on e.deptno = d.deptno
 where d.loc = 'DALLAS';
 
--26> 사원이름 및 사원번호, 해당 관리자이름 및 관리자 번호를 출력하되,
-- 각 컬럼명을 employee,emp#,manager,mgr#으로 표시하여 출력하라.
 
--27> 모든 사원의 이름,직업,부서이름,급여 및 등급을 출력하라.
 select e.ename , e.job , e.deptno, e.sal, s.grade
 from emp e join salgrade s 
 on e.sal between s.losal and s.hisal;
 

--28> Smith보다 늦게 입사한 사원의 이름 및 입사일을 출력하라.
 
--29> 자신의 관리자보다 먼저 입사한 모든 사원의 이름, 입사일, 
-- 관리자의 이름, 관리자의 입사일을 출력하되 각각 컬럼명을 
-- Employee,EmpHiredate, Manager,MgrHiredate로 표시하여 
-- 출력하라.
select e.ename as employee , e.hiredate as emphiredate, d.ename as manager , d.hiredate as mgrhiredate 
from emp e join emp d
on  e.mgr = d.empno and e.mgr is not null
where to_date(d.hiredate) > to_date(e.hiredate);
 
 
--30> 모든 사원의 급여 최고액,최저액,총액 및 평균액을 출력하되 
-- 각 컬럼명을 Maximum,Minimum,Sum,Average로 지정하여 출력하라.
 
--31> 각 직업별로 급여 최저액.최고액,총액 및 평균액을 출력하라.
 select job,min(sal),max(sal),sum(sal),round(avg(sal))
 from emp
 group by job;
 
 
 
--32> 직업이 동일한 사람 수를 직업과 같이 출력하라.
 
--33> 관리자의 수를 출력하되, 관리자 번호가 중복되지 않게하라.
-- 그리고, 컬럼명을 Number of Manager로 지정하여 출력하라.
 select count(distinct MGR) as "number of manager"
 from emp;
 
 select *from emp;
--34> 최고 급여와 최저 급여의 차액을 출력하라.
 
--35> 관리자 번호 및 해당 관리자에 속한 사원들의 최저 급여를 출력하라.
-- 단, 관리자가 없는 사원 및 최저 급여가 1000 미만인 그룹은 제외시키고 
-- 급여를 기준으로 출력 결과를 내림차순으로 정렬하라.
select min(sal) ,mgr 
from emp
where mgr is not null
group by mgr
having min(sal) > 1000 
order by min(sal) desc;


--36> 부서별로 부서이름, 부서위치, 사원 수 및 평균 급여를 출력하라.
-- 그리고 각각의 컬럼명을 부서명,위치,사원의 수,평균급여로 표시하라.
 
 
--37> Smith와 동일한 부서에 속한 모든 사원의 이름 및 입사일을 출력하라.
-- 단, Smith는 제외하고 출력하시오
 select ename, hiredate
 from emp
 where deptno = (select deptno from emp where ename = 'SMITH') and ename != 'SMITH';
 
--38> 자신의 급여가 평균 급여보다 많은 모든 사원의 사원 번호, 이름, 급여를 
--    표시하는 질의를 작성하고 급여를 기준으로 결과를 내림차순으로 정렬하라.
 
 
--39> 이름에 T가 들어가는 사원의 속한 부서
--에서 근무하는 모든 사원의 사원번호
-- 및 이름을 출력하라.
 select empno , ename
 from emp
 where deptno in (select deptno from emp where ename like '%T%');
 
 
 
 
--40> 부서위치가 Dallas인 모든 사원의 이름,부서번호 및 직위를 출력하라.
 
 
--41> KING에게 보고하는 모든 사원의 이름과 급여를 출력하라.
 select ename,sal
 from emp
 where mgr=(select empno from emp where ename='KING');
 
--42> Sales 부서의 모든 사원에 대한 부서번호, 이름 및 직위를 출력하라.
 
 
--43> 자신의 급여가 평균 급여보다 많고 이름에 T가 들어가는 사원과 동일한
-- 부서에 근무하는 모든 사원의 사원 번호, 이름 및 급여를 출력하라.
 select empno,ename,sal
 from emp
 where deptno in (select deptno from emp where ename like '%T%') and sal > (select avg(sal) from emp);



 
--44> 커미션을 받는 사원과 급여가 일치하는 사원의 이름,부서번호,급여를 
-- 출력하라.
 
 
--45> Dallas에서 근무하는 사원과 직업이 일치하는 사원의 이름,부서이름,
--     및 급여를 출력하시오
 select ename,deptno,sal,job
 from emp
 where job in (select e.job from emp e join dept d on e.deptno=d.deptno where d.loc='DALLAS');

--46> Scott과 동일한 급여 및 커미션을 받는 모든 사원의 이름, 입사일 및 
-- 급여를 출력하시오
 
 
--47> 직업이 Clerk 인 사원들보다 더 많은 급여를 받는 사원의 사원번호,
-- 이름, 급여를 출력하되, 결과를 급여가 높은 순으로 정렬하라.
 select empno,ename,sal
 from emp e  
 where sal in (select sal from emp   where job='CLERK');
 order by sal desc;
  
  select sal from emp where job='CLERK';
--48> 이름에 A가 들어가는 사원과 같은 직업을 가진 사원의 이름과
-- 월급, 부서번호를 출력하라.
 
 
--49> New  York 에서 근무하는 사원과 급여 및 커미션이 같은 사원의 
-- 사원이름과 부서명을 출력하라.
 select *
 from emp e 
 where sal in (select sal from emp e join dept d  on e.deptno = d.deptno where d.loc = 'NEW YORK')
 
 
--50> Dallas에서 근무하는 사원과 직업 및 관리자가 같은 사원의 사원번호,사원이름,
--    직업,월급,부서명,커미션을 출력하되 커미션이 책정되지 않은 사원은 NoCommission
--    으로 표시하고, 커미션의 컬럼명은 Comm으로 나오게 출력하시오.
--    단, 최고월급부터 출력되게 하시오











-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [SQL 1차 학습 END] 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- [SQL 2차 학습 START]
--3차 프로젝트 전
--고급 쿼리 (순위)
--PL-SQL
--변수 , 제어문 , 커서 , 함수 , 프로시져, 트리거 , 스케줄

